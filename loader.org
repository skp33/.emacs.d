#+TITLE: My GNU Emacs configuration
#+AUTHOR: Kaushal Prajapati
#+EMAIL: kaushal.prajapati3@gmail.com
#+STARTUP: indent
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-bable
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction

This is my version of an configuration file for GNU Emacs, which is combination of both [[https://github.com/munen/emacs.d]] and [[https://gitlab.com/buildfunthings/emacs-config]] emacs confugurations.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Kaushal Prajapati")
  (setq user-mail-address "kaushal.prajapati3@gmail.com")
#+END_SRC

* A secure Emacs environment

Great article why [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your editor is malware]]. The following basically sets up the configuration to adhere to the articles recommondations.

#+BEGIN_SRC shell :exports none
python -m pip install --user certifi
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;  (if (fboundp 'gnutls-available-p)
  ;;      (fmakunbound 'gnutls-available-p))

  (require 'cl)
  (setq tls-checktrust t)

  (setq python (or (executable-find "py.exe")
                   (executable-find "python")
                   ))

  (let ((trustfile
         (replace-regexp-in-string
          "\\\\" "/"
          (replace-regexp-in-string
           "\n" ""
           (shell-command-to-string (concat python " -m certifi"))))))
    (setq tls-program
          (list
           (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                   (if (eq window-system 'w32) ".exe" "") trustfile)))
    (setq gnutls-verify-error t)
    (setq gnutls-trustfiles (list trustfile)))

  ;; Test the settings by using the following code snippet:
  ;;  (let ((bad-hosts
  ;;         (loop for bad
  ;;               in `("https://wrong.host.badssl.com/"
  ;;                    "https://self-signed.badssl.com/")
  ;;               if (condition-case e
  ;;                      (url-retrieve
  ;;                       bad (lambda (retrieved) t))
  ;;                    (error nil))
  ;;               collect bad)))
  ;;    (if bad-hosts
  ;;        (error (format "tls misconfigured; retrieved %s ok" bad-hosts))
  ;;      (url-retrieve "https://badssl.com"
  ;;                    (lambda (retrieved) t))))
#+END_SRC

* Installing use-package
** Setup

Here's a pretty comprehensive group of magic invocations to make Emacs use UTF-8 everywhere by default:

#+BEGIN_SRC emacs-lisp
(setq utf-translate-cjk-mode nil) ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
  (set-language-environment 'utf-8)
  (set-keyboard-coding-system 'utf-8-mac) ; For old Carbon emacs on OS X only
  (setq locale-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system
    (if (eq system-type 'windows-nt)
        'utf-16-le  ;; https://rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows
      'utf-8))
  (prefer-coding-system 'utf-8)
#+END_SRC

GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
  (require 'package)
#+END_SRC

Because the default setting for package-archives is to use the HTTP access to the GNU archive, I set the variable to `nil` before adding the HTTPS variants.

#+name: credmp-package-infrastructure
#+begin_src emacs-lisp

  (defvar gnu '("gnu" . "https://elpa.gnu.org/packages/"))
  (defvar melpa '("melpa" . "https://melpa.org/packages/"))
  (defvar melpa-stable '("melpa-stable" . "https://stable.melpa.org/packages/"))

  ;; Add marmalade to package repos
  (setq package-archives nil)
  (add-to-list 'package-archives melpa-stable t)
  (add-to-list 'package-archives melpa t)
  (add-to-list 'package-archives gnu t)
#+end_src

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
               (file-exists-p (concat init-dir "elpa/archives/melpa"))
               (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
    (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+name: credmp-package-installer
#+BEGIN_SRC emacs-lisp
  (defun packages-install (&rest packages)
    (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC

** The package

#+name: credmp-package-installer
#+BEGIN_SRC emacs-lisp
  ;; Install extensions if they're missing
  (defun init--install-packages ()
    (message "Lets install some packages")
    (packages-install
     ;; Since use-package this is the only entry here
     ;; ALWAYS try to use use-package!
     (cons 'use-package melpa)
     ))

  (condition-case nil
      (init--install-packages)
    (error
     (package-refresh-contents)
     (init--install-packages)))
#+END_SRC

Updated all packages on startup

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :ensure t
  :config
  (auto-package-update-maybe))
#+END_SRC

Auto-refresh all buffers when files have changed on disk

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

Add ability to bind actions to series of key strokes

#+BEGIN_SRC emacs-lisp
  (use-package key-chord
  :ensure t
  :config
  (key-chord-mode 1))
#+END_SRC

** Dimish modes

#+BEGIN_SRC emacs-lisp
(use-package diminish
 :ensure t)
#+END_SRC

* Default Settings
This section contains settings for built-in Emacs features.

** Gargabe Collection

Allow 20MB of memory (instead of 0.76MB) before calling garbage
collection. This means GC runs less often, which speeds up some
operations.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 20000000)
#+END_SRC

** Do not create backup files
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

** Move to trash when deleting stuff and write backup files to own directory
Store backups and auto-saved files in =backups=, instead of in the same directory as the
file.

#+name: credmp-trash
#+begin_src emacs-lisp
  ;; Backup settings
  (defvar --backup-directory (concat init-dir "backups"))

  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))

  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        )
    (setq delete-by-moving-to-trash t
          trash-directory "~/.Trash/emacs")

    (setq backup-directory-alist `(("." . ,(expand-file-name
                                            (concat init-dir "backups")))))
#+end_src

** Always follow symlinks
   When opening a file, always follow symlinks.

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

** Sentences have one space after a period
Don't assume that sentences should have two spaces after
periods.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** Confirm before closing Emacs
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** =dired-mode=

Ability to use =a= to visit a new directory or file in =dired= instead
of using =RET=. =RET= works just fine, but it will create a new buffer
for /every/ interaction whereas =a= reuses the current buffer.

#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

Human readable units

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-alh")
#+END_SRC

** Ask =y/n= instead of =yes/no=
   This is a favorable shorthand.
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Auto revert files on change
When something changes a file, automatically refresh the
buffer containing that file so they can't get out of sync.

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC

** Matching Titlebar color on MacOS
If you're using Emacs on macOS, you can add this to have your titlebar color changed and matching your color theme

#+BEGIN_SRC emacs-lisp
;; Fancy titlebar for MacOS
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
(add-to-list 'default-frame-alist '(ns-appearance . dark))
(setq ns-use-proxy-icon  nil)
(setq frame-title-format nil)
#+END_SRC

** Shortcut for changing font-size
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-1") 'text-scale-increase)
  (define-key global-map (kbd "C-0") 'text-scale-decrease)
#+END_SRC
** Disable startup message

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+END_SRC

** Display the current time
#+BEGIN_SRC emacs-lisp
  (display-time-mode t)
#+END_SRC

** Do not display GUI Toolbar

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
#+END_SRC

** Automatic Line Breaks
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

** Enable Narrow To Region

Enable narrow-to-region (C-x n n / C-x n w). This is disabled by
default to not confuse beginners.

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** Disable scroll bars
#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
#+END_SRC
** Remember the cursor position of files when reopening them
#+BEGIN_SRC emacs-lisp
  (setq save-place-file "~/.emacs.d/saveplace")
  (setq-default save-place t)
  (require 'saveplace)
#+END_SRC
** Set $MANPATH, $PATH and exec-path from shell even when started from GUI helpers like =dmenu= or =Spotlight=

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t)
    (exec-path-from-shell-initialize)

#+END_SRC
** =windmove=

Windmove is built into Emacs. It lets you move point from window to
window using Shift and the arrow keys. This is easier to type than
‘C-x o’ when there are multiple windows open.

#+BEGIN_SRC emacs-lisp

(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings))

#+END_SRC

** =winner-mode=

Allows to 'undo' (and 'redo') changes in the window configuration with
the key commands ‘C-c left’ and ‘C-c right’.

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

Getting from many windows to one window is easy: 'C-x 1' will do it.
But getting back to a delicate WindowConfiguration is difficult. This
is where Winner Mode comes in: With it, going back to a previous
session is easy.

** Bell
   Do not ring the system bell, but show a visible feedback.

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

** AngeFtp
Try to use passive mode for FTP.

Note: Some firewalls might not allow standard active mode. However:
Some FTP Servers might not allow passive mode. So if there's problems
when connecting to an FTP, try to revert to active mode.
#+BEGIN_SRC emacs-lisp
(setq ange-ftp-try-passive-mode t)
#+END_SRC

** eww
   When entering eww, use cursors to scroll without changing point.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eww-mode-hook 'scroll-lock-mode)
#+END_SRC

* General
This section contains settings for non-built-in Emacs features that
are generally applicable to different kinds of modes.
** =beacon-mode=
https://github.com/Malabarba/beacon

Whenever the window scrolls a light will shine on top of your cursor so you know where it is.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1))
#+END_SRC
** =browse-kill-ring=
Ever wish you could just look through everything you've killed
recently to find out if you killed that piece of text that you think
you killed (or yanked), but you're not quite sure? If so, then
browse-kill-ring is the Emacs extension for you.

#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring :ensure t)
  (require 'browse-kill-ring)
  (setq browse-kill-ring-highlight-inserted-item t
        browse-kill-ring-highlight-current-entry nil
        browse-kill-ring-show-preview t)
  (define-key browse-kill-ring-mode-map (kbd "j") 'browse-kill-ring-forward)
  (define-key browse-kill-ring-mode-map (kbd "k") 'browse-kill-ring-previous)
#+END_SRC

** =evil-mode=
Evil is an extensible Vim layer for Emacs.

This combines the best of both worlds: VIM being a great text-editor
with modal editing through semantic commands and Emacs being a LISP
REPL.
** Enable Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil :ensure t)
  ;; Enable "M-x" in evil mode
  (global-set-key (kbd "M-x") 'execute-extended-command)
#+END_SRC

*** Leader Mode Config

#+BEGIN_SRC emacs-lisp
  (use-package evil-leader :ensure t)
  (global-evil-leader-mode)
  (evil-leader/set-leader ",")
  (evil-leader/set-key
    "w" 'basic-save-buffer
    "s" 'flyspell-buffer
    "b" 'evil-buffer
    "q" 'evil-quit)
#+END_SRC

*** Evil Surround, emulating tpope's =surround.vim=

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1))
#+END_SRC

*** Multiple Cursors
https://github.com/gabesoft/evil-mc

=evil-mc= provides multiple cursors functionality for Emacs when used
with =evil-mode=.

=C-n / C-p= are used for creating cursors, and =M-n / M-p= are used
for cycling through cursors. The commands that create cursors wrap
around; but, the ones that cycle them do not. To skip creating a
cursor forward use =C-t= or =grn= and backward =grp=. Finally use
=gru= to remove all cursors.

*** Enable =evil-mc= for all buffers

#+BEGIN_SRC emacs-lisp
  (use-package evil-mc :ensure t)
  (global-evil-mc-mode  1)
#+END_SRC

*** Fast switching between buffers
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "{") 'evil-next-buffer)
  (define-key evil-normal-state-map (kbd "}") 'evil-prev-buffer)
#+END_SRC

*** Increment / Decrement numbers

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-=") 'evil-numbers/inc-at-pt)
  (global-set-key (kbd "C--") 'evil-numbers/dec-at-pt)
  (define-key evil-normal-state-map (kbd "C-=") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C--") 'evil-numbers/dec-at-pt)
#+END_SRC

*** Use =j/k= for browsing wrapped lines
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
  (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+END_SRC

*** Paste in Visual Mode

#+BEGIN_SRC emacs-lisp
  (define-key evil-insert-state-map (kbd "C-v") 'evil-visual-paste)

#+END_SRC

*** Disable =evil-mode= for some modes
   Since Emacs is a multi-purpose LISP REPL, there are many modes that
   are not primarily (or not at all) centered about text-manipulation.
   For those, it is reasonable to disable =evil-mode=, because it will
   bring nothing to the table, but might just shadow some keyboard
   shortcuts.
#+BEGIN_SRC emacs-lisp
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs)) '(elfeed-show-mode
                                                  elfeed-search-mode
                                                  dired-mode
                                                  image-dired-mode
                                                  image-dired-thumbnail-mode
                                                  eww-mode))
#+END_SRC
*** Unbind M-. and M- in =evil-mode=
=M-.= and =M-,= are popular keybindings for "jump to definition" and
"back". =evil-mode= by default binds those to rather rarely used
functions =evil-repeat-pop-next= and =xref-pop-marker-stack=, for some reason.

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "M-.") nil)
  (define-key evil-normal-state-map (kbd "M-,") nil)
#+END_SRC
*** =evil-escape=
https://github.com/syl20bnr/evil-escape

Escape from insert state and everything else.

#+BEGIN_SRC emacs-lisp
  (use-package evil-escape :ensure t)
  (setq-default evil-escape-delay 0.2)
  (setq-default evil-escape-key-sequence "jk")
  (evil-escape-mode)
#+END_SRC

This results in the same feature-set like this vim keybinding:
#+BEGIN_SRC vim
"Remap ESC to jk
:imap jk <esc>
#+END_SRC

* Which Key
  =which-key= displays available keybindings in a popup.

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1)
  (add-hook 'org-mode-hook 'which-key-mode))
#+END_SRC

* Programming
*** Auto Complete
https://github.com/auto-complete/auto-complete

Basic Configuration
#+BEGIN_SRC emacs-lisp
 (use-package auto-complete
  :ensure t
  :config
  (ac-config-default))
#+END_SRC
*** Tabs
Set tab width to 2 for all buffers

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC

Use 2 spaces instead of a tab.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2 indent-tabs-mode nil)
#+END_SRC

Indentation cannot insert tabs.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Use 2 spaces instead of tabs for programming languages.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (setq coffee-tab-width 2)

  (setq python-indent 2)

  (setq css-indent-offset 2)

  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))

  (setq web-mode-markup-indent-offset 2)
#+END_SRC

*** Syntax Checking

http://www.flycheck.org/

Enable global on the fly syntax checking through =flycheck=.

#+BEGIN_SRC emacs-lisp
 (use-package flycheck
  :ensure t
  :config
  (add-hook 'after-init-hook #'global-flycheck-mode))

#+END_SRC
*** Manage TODO/FIXME/XXX comments

https://github.com/vincekd/comment-tags

=comment-tags= highlights and lists comment tags such as 'TODO', 'FIXME', 'XXX'.

Commands (prefixed by =C-c t=):

    - =b= to list tags in current buffer (comment-tags-list-tags-buffer).
    - =a= to list tags in all buffers (comment-tags-list-tags-buffers).
    - =s= to jump to tag in current buffer by a word or phrase using reading-completion (comment-tags-find-tags-buffer).
    - =n= to jump to next tag from point (comment-tags-next-tag).
    - =p= to jump to previous tag from point (comment-tags-previous-tag).

#+BEGIN_SRC emacs-lisp
 (use-package comment-tags
  :ensure t)
  (setq comment-tags-keymap-prefix (kbd "C-c t"))
  (with-eval-after-load "comment-tags"
    (setq comment-tags-keyword-faces
          `(("TODO" . ,(list :weight 'bold :foreground "#DF5427"))
            ("FIXME" . ,(list :weight 'bold :foreground "#DF5427"))
            ("BUG" . ,(list :weight 'bold :foreground "#DF5427"))
            ("HACK" . ,(list :weight 'bold :foreground "#DF5427"))
            ("KLUDGE" . ,(list :weight 'bold :foreground "#DF5427"))
            ("XXX" . ,(list :weight 'bold :foreground "#DF5427"))
            ("INFO" . ,(list :weight 'bold :foreground "#1FDA9A"))
            ("DONE" . ,(list :weight 'bold :foreground "#1FDA9A"))))
    (setq comment-tags-comment-start-only t
          comment-tags-require-colon t
          comment-tags-case-sensitive t
          comment-tags-show-faces t
          comment-tags-lighter nil))
  (add-hook 'prog-mode-hook 'comment-tags-mode)
#+END_SRC

*** Auto-indent with the Return key

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Highlight matching parenthesis

#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
#+END_SRC

*** Delete trailing whitespace

Delete trailing whitespace in all modes. _Except_ when editing
Markdown, because it uses [[http://daringfireball.net/projects/markdown/syntax#p][two trailing blanks]] as a signal to create a
line break.

#+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook '(lambda()
                                  (when (not (or (derived-mode-p 'markdown-mode)
                                                 (derived-mode-p 'org-mode))
                                    (delete-trailing-whitespace)))))
#+END_SRC

*** Code Folding

Enable code folding for programming modes.

- =zc=: Fold
- =za=: Unfold
- =zR=: Unfold everything

#+BEGIN_SRC emacs-lisp

(add-hook 'prog-mode-hook #'hs-minor-mode)

#+END_SRC

** Gradle

#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
    :ensure t
    :config
    (gradle-mode 1)
;;    (setq gradle-use-gradlew 'true)
)
#+END_SRC

** Scala
Adding ensime and scala mode

#+BEGIN_SRC emacs-lisp
 ;; (use-package ensime
 ;;   :ensure t)
 ;; (require 'ensime)
  (use-package scala-mode
    :ensure t
    :config
    (add-hook 'scala-mode-hook
          (lambda ()
            (gradle-mode)
            (show-paren-mode)
           ;; (smartparens-mode)
            (yas-minor-mode)
           ;; (git-gutter-mode)
            (company-mode)
            (scala-mode:goto-start-of-code)))
    (with-eval-after-load 'company (define-key company-active-map [tab] nil))
    (add-hook 'scala-mode-hook #'linum-mode))

#+END_SRC

** Web
*** rainbow-mode
=rainbow-mode= is a minor mode for Emacs which displays strings
representing colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
 (use-package rainbow-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
*** Impatient Mode

https://github.com/netguy204/imp.el

Live JavaScript Coding Emacs/Browser: See your changes in the browser as you type

**** Usage

Enable the web server provided by simple-httpd: =M-x httpd-start=

Publish buffers by enabling the minor mode impatient-mode: =M-x impatient-mode=

And then point your browser to http://localhost:8080/imp/, select a
buffer, and watch your changes appear as you type!


*** Process JSON

[[https://stedolan.github.io/jq/][jq]] is a lightweight and flexible command-line JSON processor.

Thanks to [[https://github.com/branch14/emacs.d][@branch14]] of 200ok fame for the function!

#+BEGIN_SRC emacs-lisp
(defun jq-json ()
  (interactive)
  (save-excursion
    (shell-command-on-region
     (point-min)
     (point-max)
     (read-string "Command: " "jq -M '.'") t t)))
#+END_SRC

*** web-mode

http://web-mode.org/

web-mode.el is an autonomous major-mode for editing web templates.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  ;; Handlebars
  (add-to-list 'auto-mode-alist '("\\.hbs?\\'" . web-mode))
  ;; JSON
  (add-to-list 'auto-mode-alist '("\\.json?\\'" . web-mode))

  (setq web-mode-enable-current-element-highlight t)
  (setq web-mode-ac-sources-alist
    '(("html" . (ac-source-words-in-buffer ac-source-abbrev))))
#+END_SRC

** yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
  :ensure t)
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook 'auto-fill-mode)

#+END_SRC

** Magit

Magit is an interface to the version control system Git.

*** Configuration

Create shortcut for =Magit=.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (global-set-key (kbd "C-c m") 'magit-status))
    (setq magit-diff-refine-hunk 'all)

  (use-package magit-gitflow
    :ensure t
    :config
    (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
#+END_SRC

Always sign commits with GPG

#+BEGIN_SRC emacs-lisp
 (setq magit-commit-arguments (quote ("--gpg-sign=kaushal.prajapati@go-mmt.com")))
#+END_SRC

**** Start the commit buffer in evil normal mode

#+BEGIN_SRC emacs-lisp
  (add-hook 'with-editor-mode-hook 'evil-normal-state)
#+END_SRC

** Projectile

https://github.com/bbatsov/projectile

Projectile is a project interaction library. For instance - finding
project files (=C-c p f=) or jumping to a new project (=C-c p p=).

*** Configuration

Enable Projectile globally

#+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :config
      (add-hook 'prog-mode-hook 'projectile-mode))
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC

** Dumb Jumb

https://github.com/jacktasia/dumb-jump

"Jump to definition" with support for multiple programming languages
that favors "just working". This means minimal -- and ideally zero --
configuration with absolutely no stored indexes (TAGS) or persistent
background processes.

Dumb Jump uses The Silver Searcher ag, ripgrep rg, or grep to find
potential definitions of a function or variable under point. It uses a
set of regular expressions based on the file extension, or major-mode,
of the current buffer.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :config
    (dumb-jump-mode)
    (setq dumb-jump-selector 'ivy))
#+END_SRC

*** Usage

The one important shortcut is =C-M-g= which attempts to jump to the
definition of the thing under point.

* Integration with browsers

Editing text areas in browsers can be quite tedious for the lack of a
good editor. Luckily, there's good extensions for both Chrome/Chromium
and Firefox to have a live binding to an Emacs session.

There is a good Emacs package called [[https://github.com/alpha22jp/atomic-chrome][Atomic Chrome]] which is similar to
[[https://www.emacswiki.org/emacs/Edit_with_Emacs][Edit with Emacs]], but has some advantages as below with the help of
websockets:

- The input on Emacs is reflected to the browser instantly and
  continuously.
- You can use both the browser and Emacs at the same time. They are
  updated to the same content bi-directionally.

The name "Atomic Chrome" is a bit misleading, because it actually
supports the "GhostText" protocol which allows it to be used with
Firefox, as well.

On Firefox, I'm using the [[https://github.com/GhostText/GhostText][GhostText]] addon. On Chromium, I'm using
the [[https://github.com/tuvistavie/atomic-chrome][AtomicChrome]] extension. GhostText is also available for Chrome,
but it doesn't work for me which is a non-issue, because both plugins
work just the same way: Enter a textarea, hit a button, Emacs opens
up, type the text, end the session with =C-c C-c=.

#+BEGIN_SRC emacs-lisp
  (use-package atomic-chrome
    :ensure t)
  (require 'atomic-chrome)
  ;; Handle if there is an Emacs instance running which has the server already
  ;; started
  (ignore-errors
      ;; Start the server
      (atomic-chrome-start-server))
#+END_SRC

Note: I opened a [[https://github.com/alpha22jp/atomic-chrome/pull/40][PR against AtomicChrome]] which will make the
safe-guard obsolete.

* Misc Custom Improvements

Some helper functions and packages I wrote that are only accessible
within this Git repository and not published to a package repository.

** Translations

Elisp wrapper around the dict.cc translation service. Translations are
exposed in an org-mode table.

Demo: [[https://asciinema.org/a/hMTM9EDHE0cphaDRFr4JXr1iw][https://asciinema.org/a/hMTM9EDHE0cphaDRFr4JXr1iw.png]]

*** Load dict.el

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/dict")
#+END_SRC
** Helper functions to clean up the gazillion buffers

When switching projects in Emacs, it can be prudent to clean up every
once in a while. Deleting all buffers except the current one is one of
the things I often do (especially in the long-running =emacsclient=).

#+BEGIN_SRC emacs-lisp
  (defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

=dired= will create buffers for every visited folder. This is a helper
to clear them out once you're done working with those folders.

#+BEGIN_SRC emacs-lisp

  (defun kill-dired-buffers ()
    "Kill all open dired buffers."
    (interactive)
    (mapc (lambda (buffer)
            (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
              (kill-buffer buffer)))
          (buffer-list)))
#+END_SRC
** Encode HTML to HTML entities
   Rudimentary function converting certain HTML syntax to HTML entities.
#+BEGIN_SRC emacs-lisp
  (defun encode-html (start end)
    "Encodes HTML entities; works great in Visual Mode (START END)."
    (interactive "r")
    (save-excursion
      (save-restriction
        (narrow-to-region start end)
        (goto-char (point-min))
        (replace-string "&" "&amp;")
        (goto-char (point-min))
        (replace-string "<" "&lt;")
        (goto-char (point-min))
        (replace-string ">" "&gt;"))))
#+END_SRC
** Convenience functions when working with PDF exports

When working on markdown or org-mode files that will be converted to
PDF, I use =pdf-tools= to preview the PDF and shortcuts to
automatically save, compile and reload on demand.

[[https://www.youtube.com/watch?v=Pd0JwOqh-gI][Here]] is a screencast showing how I edit Markdown or org-mode files in
Emacs whilst having a PDF preview.

#+BEGIN_SRC emacs-lisp
  (defun md-compile ()
    "Compiles the currently loaded markdown file using pandoc into a PDF"
    (interactive)
    (save-buffer)
    (shell-command (concat "pandoc " (buffer-file-name) " -o "
                           (replace-regexp-in-string "md" "pdf" (buffer-file-name)))))

  (defun update-other-buffer ()
    (interactive)
    (other-window 1)
    (revert-buffer nil t)
    (other-window -1))

  (defun md-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a markdown-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (md-compile)
    (update-other-buffer))

  (defun latex-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a latex-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (save-buffer)
    (shell-command (concat "pdflatex " (buffer-file-name)))
    (switch-to-buffer (other-buffer))
    (kill-buffer)
    (update-other-buffer))

  (defun org-compile-beamer-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-beamer-export-to-pdf)
    (update-other-buffer))

  (defun org-compile-latex-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-latex-export-to-pdf)
    (update-other-buffer))

  (eval-after-load 'latex-mode
    '(define-key latex-mode-map (kbd "C-c r") 'latex-compile-and-update-other-buffer))

  (define-key org-mode-map (kbd "C-c lr") 'org-compile-latex-and-update-other-buffer)
  (define-key org-mode-map (kbd "C-c br") 'org-compile-beamer-and-update-other-buffer)

  (eval-after-load 'markdown-mode
    '(define-key markdown-mode-map (kbd "C-c r") 'md-compile-and-update-other-buffer))
#+END_SRC
** Use left Cmd to create Umlauts

Unrelated to Emacs, in macOS, you can write Umlauts by using the combo
=M-u [KEY]=. For example =M-u u= will create the letter =ü=.

This is actually faster than the default way of Emacs or that of VIM.
The following code ports that functionality to Emacs.

Thx [[https://github.com/jcfischer][@jcfischer]] for the function!

#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map [dead-diaeresis]
    (lookup-key key-translation-map "\C-x8\""))
  (define-key isearch-mode-map [dead-diaeresis] nil)
  (global-set-key (kbd "M-u")
                  (lookup-key key-translation-map "\C-x8\""))

#+END_SRC

** Clean up messy buffers (i.e. web wikis or elfeed-show)
#+BEGIN_SRC emacs-lisp

  (defun visual-clean ()
    "Clean up messy buffers (i.e. web wikis or elfeed-show)"
    (interactive)
    (visual-line-mode)
    (visual-fill-column-mode))

#+END_SRC
** Generate passwords
   Through =pwgen=.

   Thanks to [[https://github.com/branch14/emacs.d][@branch14]] of 200ok fame for the function!
#+BEGIN_SRC emacs-lisp

(defun generate-password-non-interactive ()
   (string-trim (shell-command-to-string "pwgen -A 24")))

(defun generate-password ()
  "Generates and inserts a new password"
  (interactive)
  (insert
   (shell-command-to-string
    (concat "pwgen -A " (read-string "Length: " "24") " 1"))))

#+END_SRC
** Open passwords file
   #+BEGIN_SRC emacs-lisp
     (defun passwords ()
       "Open main 'passwords' file."
       (interactive)
       (find-file (concat org-directory "vault/primary.org.gpg")))
   #+END_SRC
** Running =M-x shell= with =zsh=
   If you're a =zsh= user, you might have configured a custom prompt
   and such. Also, you might be using a powerful =$TERM= for that.
   When running =zsh= within =M-x shell=, you will have to set the
   =$TERM= to =dumb=, though. Otherwise you'll get all kinds of escape
   sequences instead of colored text.

I'm using this within my =~/.zshrc=

#+BEGIN_SRC shell
# This allows running `shell` properly within Emacs
if [ -n "$INSIDE_EMACS" ]; then
  export TERM=dumb
else
  export TERM=xterm-256color
fi
#+END_SRC

** =server-shutdown=
This is the converse function to the built-in =server-start=.
#+BEGIN_SRC emacs-lisp
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs))
#+END_SRC
* All yasnippet configs + functions used

#+BEGIN_SRC emacs-lisp

(use-package yasnippet
  :ensure t)

(setq yas-snippet-dirs
      '("~/.emacs.d/snippets"
        "~/.emacs.d/my_snippets"
        ))

(yas-global-mode 1)

(yas-reload-all)
(defun find-git-repo (dir)
  (if (string= "/" dir)
      nil
    (if (file-exists-p (expand-file-name ".git/" dir))
        dir
      (find-git-repo (expand-file-name "../" dir)))))

(defun find-project-root ()
  (interactive)
  (if (ignore-errors (eproject-root))
      (eproject-root)
    (or (find-git-repo (buffer-file-name)) (file-name-directory (buffer-file-name)))))

(defun file-path-to-namespace ()
  (interactive)
  (let (
        (root (find-project-root))
        (base (file-name-nondirectory buffer-file-name))
        )
    (substring (replace-regexp-in-string "/" "\\" (substring buffer-file-name (length root)\
 (* -1 (length base))) t t) 0 -1)
    )
  )
#+END_SRC

* Moving around

Be sure to just ask for y/n instead of yes/no.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-]") 'next-buffer)
(global-set-key (kbd "M-[") 'previous-buffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Bookmarks are very useful for quickly jumping around files.

#+BEGIN_SRC emacs-lisp
  (use-package bm
    :ensure t
    :bind (("C-c =" . bm-toggle)
           ("C-c [" . bm-previous)
           ("C-c ]" . bm-next)))

#+END_SRC


#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . counsel-M-x)
     ("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

   (use-package swiper
     :pin melpa-stable
     :diminish ivy-mode
     :ensure t
     :bind*
     (("C-s" . swiper)
      ("C-c C-r" . ivy-resume)
      ("C-x C-f" . counsel-find-file)
      ("C-c h f" . counsel-describe-function)
      ("C-c h v" . counsel-describe-variable)
      ("C-c i u" . counsel-unicode-char)
      ("M-i" . counsel-imenu)
      ("C-c g" . counsel-git)
      ("C-c j" . counsel-git-grep)
      ("C-c k" . counsel-ag)
;;      ("C-c l" . scounsel-locate)
)
     :config
     (progn
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (define-key read-expression-map (kbd "C-r") #'counsel-expression-history)
       (ivy-set-actions
        'counsel-find-file
        '(("d" (lambda (x) (delete-file (expand-file-name x)))
           "delete"
           )))
       (ivy-set-actions
        'ivy-switch-buffer
        '(("k"
           (lambda (x)
             (kill-buffer x)
             (ivy--reset-state ivy-last))
           "kill")
          ("j"
           ivy--switch-buffer-other-window-action
           "other window")))))

  (use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-mode))

  (use-package ivy-hydra :ensure t)
#+END_SRC

From [[http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/][Pragmatic Emacs]] a more concise way to kill the buffer.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

Mousewheel scrolling can be quite annoying, lets fix it to scroll
smoothly.

#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
(setq mouse-wheel-progressive-speed nil)
#+end_src

* Environment

#+name: starter-kit-osX-workaround
#+begin_src emacs-lisp
  (if (or
       (eq system-type 'darwin)
       (eq system-type 'berkeley-unix))
      (setq system-name (car (split-string system-name "\\."))))

  (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
  (push "/usr/local/bin" exec-path)

  ;; /usr/libexec/java_home
  ;;(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home")
#+end_src

** GUI

- change command to meta, and ignore option to use weird Norwegian
keyboard

#+name: credmp-keys
#+begin_src emacs-lisp
  (setq mac-option-modifier 'none)
  (setq mac-command-modifier 'meta)
  (setq ns-function-modifier 'hyper)
#+end_src

- use default mac notifier 

#+BEGIN_SRC emacs-lisp
  (setq alert-default-style 'osx-notifier)  
#+END_SRC

- Don't open files from the workspace in a new frame

#+name: credmp-trash
#+begin_src emacs-lisp
  (setq ns-pop-up-frames nil)
#+end_src

[[https://www.emacswiki.org/emacs/InteractiveSpell][Spellchecking in Emacs]]. Hunspell is widely used in text editor and even as the source of the spell check in MacOS X.

Install using the Homebrew project:

#+BEGIN_SRC shell :exports none
  brew install hunspell
#+END_SRC

Install dictionaries from the [[https://addons.mozilla.org/en-us/firefox/language-tools/][Mozilla Add-on page]].

#+name: credmp-spell
#+begin_src emacs-lisp
    (defun spell-buffer-dutch ()
      (interactive)
      (ispell-change-dictionary "nl_NL")
      (flyspell-buffer))

    (defun spell-buffer-english ()
      (interactive)
      (ispell-change-dictionary "en_US")
      (flyspell-buffer))

    (use-package ispell
      :config
      (when (executable-find "hunspell")
        (setq-default ispell-program-name "hunspell")
        (setq ispell-really-hunspell t))

      ;; (setq ispell-program-name "aspell"
      ;;       ispell-extra-args '("--sug-mode=ultra"))
      :bind (("C-c N" . spell-buffer-dutch)
             ("C-c n" . spell-buffer-english)))
#+end_src

- Find out what face is used, so you can customize it :)

#+name: credmp-spell
#+begin_src emacs-lisp
  ;;; what-face to determine the face at the current point
  (defun what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+end_src

- Windows management

#+name: credmp-window
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (global-set-key (kbd "C-x o") 'ace-window)
    (key-chord-define-global "gh" 'ace-window))

  (use-package ace-jump-mode
    :ensure t
    :config
    (define-key global-map (kbd "C-c SPC") 'ace-jump-mode))
#+end_src

- Misc stuff

#+name: credmp-spell
#+begin_src emacs-lisp
  ;; Custom binding for magit-status
  (use-package magit
    :ensure t
    :config
    (global-set-key (kbd "C-c m") 'magit-status))

  (use-package magit-gitflow
    :ensure t
    :config
    (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))

  (setq inhibit-startup-message t)
;;  (global-linum-mode)

  (defun iwb ()
    "indent whole buffer"
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max)))

  (global-set-key (kbd "C-c n") 'iwb)

  (electric-pair-mode t)

#+end_src

* Look and feel

#+name: credmp-package-installer
#+begin_src emacs-lisp
  (when (window-system)
    (use-package arjen-grey-theme
      :ensure t
      :config
      (load-theme 'arjen-grey t)))

    ;; (use-package base16-theme
    ;;   :ensure t
    ;;   :config
    ;;   (load-theme 'base16-materia))

    ;; (if (or (eq system-type 'darwin)(eq system-type 'gnu/linux) )
    ;;     (set-face-attribute 'default nil :font "Fira Code-16")
    ;;   (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 110))

  (when (window-system)
    (set-default-font "Hack"))
  ;; (let ((alist '((33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
  ;;                (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
  ;;                (36 . ".\\(?:>\\)")
  ;;                (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
  ;;                (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
  ;;                (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
  ;;                (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
  ;;                (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
  ;;                ;; might need to uncomment the below for Cider.
  ;;                (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
  ;;                (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
  ;;                (48 . ".\\(?:x[a-zA-Z]\\)")
  ;;                (58 . ".\\(?:::\\|[:=]\\)")
  ;;                (59 . ".\\(?:;;\\|;\\)")
  ;;                (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
  ;;                (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
  ;;                (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
  ;;                (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
  ;;                (91 . ".\\(?:]\\)")
  ;;                (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
  ;;                (94 . ".\\(?:=\\)")
  ;;                (119 . ".\\(?:ww\\)")
  ;;                (123 . ".\\(?:-\\)")
  ;;                (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
  ;;                (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
  ;;                )
  ;;              ))
  ;;   (dolist (char-regexp alist)
  ;;     (set-char-table-range composition-function-table (car char-regexp)
  ;;                           `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package command-log-mode
    :ensure t)

  (defun live-coding ()
    (interactive)
    (set-face-attribute 'default nil :font "Hack-18")
    (add-hook 'prog-mode-hook 'command-log-mode)
    ;;(add-hook 'prog-mode-hook (lambda () (focus-mode 1)))
    )

  (defun normal-coding ()
    (interactive)
    (set-face-attribute 'default nil :font "Hack-14")
    (add-hook 'prog-mode-hook 'command-log-mode)
    ;;(add-hook 'prog-mode-hook (lambda () (focus-mode 1)))
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
   (eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC

Have the ability to use some amazing font icons

#+BEGIN_SRC emacs-lisp
;;   (use-package all-the-icons
;;     :ensure t)
#+END_SRC

Be sure to install the fonts from [[https://github.com/domtronn/all-the-icons.el/tree/master/fonts][the github repo]].

Now, lets make sure we are not `ding`-ed all the time.

#+BEGIN_SRC emacs-lisp
  ;; http://stackoverflow.com/questions/11679700/emacs-disable-beep-when-trying-to-move-beyond-the-end-of-the-document
  (defun my-bell-function ())

  (setq ring-bell-function 'my-bell-function)
  (setq visible-bell nil)
#+END_SRC

* Writing

** Publishing

Based on the work describe [[https://medium.com/@lakshminp/publishing-a-book-using-org-mode-9e817a56d144#.90pg5dl66][here]].

Support to make an external call to LeanPub.

#+BEGIN_SRC emacs-lisp
  (use-package request
    :ensure t)
#+END_SRC

You will need the ox-leanpub library from GitHub.

#+BEGIN_SRC shell :exports none
  wget https://raw.githubusercontent.com/juanre/ox-leanpub/master/ox-leanpub.el
#+END_SRC

Now for the leanpub-export.

#+BEGIN_SRC emacs-lisp
  ;;(add-to-list 'load-path (expand-file-name (concat init-dir "ox-leanpub")))
  ;;(load-library "ox-leanpub")
  ;;(add-to-list 'load-path (expand-file-name (concat init-dir "ox-ghost")))
  ;;(load-library "ox-ghost")
  ;;; http://www.lakshminp.com/publishing-book-using-org-mode

  ;;(defun leanpub-export ()
  ;;  "Export buffer to a Leanpub book."
  ;;  (interactive)
  ;;  (if (file-exists-p "./Book.txt")
  ;;      (delete-file "./Book.txt"))
  ;;  (if (file-exists-p "./Sample.txt")
  ;;      (delete-file "./Sample.txt"))
  ;;  (org-map-entries
  ;;   (lambda ()
  ;;     (let* ((level (nth 1 (org-heading-components)))
  ;;            (tags (org-get-tags))
  ;;            (title (or (nth 4 (org-heading-components)) ""))
  ;;            (book-slug (org-entry-get (point) "TITLE"))
  ;;            (filename
  ;;             (or (org-entry-get (point) "EXPORT_FILE_NAME") (concat (replace-regexp-in-string " " "-" (downcase title)) ".md"))))
  ;;       (when (= level 1) ;; export only first level entries
  ;;         ;; add to Sample book if "sample" tag is found.
  ;;         (when (or (member "sample" tags)
  ;;                   ;;(string-prefix-p "frontmatter" filename) (string-prefix-p "mainmatter" filename)
  ;;                   )
  ;;           (append-to-file (concat filename "\n\n") nil "./Sample.txt"))
  ;;         (append-to-file (concat filename "\n\n") nil "./Book.txt")
  ;;         ;; set filename only if the property is missing
  ;;         (or (org-entry-get (point) "EXPORT_FILE_NAME")  (org-entry-put (point) "EXPORT_FILE_NAME" filename))
  ;;         (org-leanpub-export-to-markdown nil 1 nil)))) "-noexport")
  ;;  (org-save-all-org-buffers)
  ;;  nil
  ;;  nil)
  ;;
  ;;(require 'request)
  ;;
  ;;(defun leanpub-preview ()
  ;;  "Generate a preview of your book @ Leanpub."
  ;;  (interactive)
  ;;  (request
  ;;   "https://leanpub.com/clojure-on-the-server/preview.json" ;; or better yet, get the book slug from the buffer
  ;;   :type "POST"                                             ;; and construct the URL
  ;;   :data '(("api_key" . ""))
  ;;   :parser 'json-read
  ;;   :success (function*
  ;;             (lambda (&key data &allow-other-keys)
  ;;               (message "Preview generation queued at leanpub.com.")))))
#+END_SRC

** Word wrapping

Please wrap text around when in text-modes. Also enable flyspell to catch nasty writing errors.

#+BEGIN_SRC emacs-lisp
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda ()
                     (flyspell-mode 1)
                     (visual-line-mode 1)
                     )))
#+END_SRC

** Markdown support

Markdown is a great way to write documentation, not as good as org-mode of course, but generally accepted as a standard.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

** HTMLize buffers

When exporting documents to HTML documents, such as code fragments, we need to htmlize.

#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Exports
Export ORG code fragments with a particular theme.

#+BEGIN_SRC emacs-lisp
(defun my/with-theme (theme fn &rest args)
  (let ((current-themes custom-enabled-themes))
    (mapcar #'disable-theme custom-enabled-themes)
    (load-theme theme t)
    (let ((result (apply fn args)))
      (mapcar #'disable-theme custom-enabled-themes)
      (mapcar (lambda (theme) (load-theme theme t)) current-themes)
      result)))

;;(advice-add #'org-export-to-file :around (apply-partially #'my/with-theme 'arjen-grey))
;;(advice-add #'org-export-to-buffer :around (apply-partially #'my/with-theme 'arjen-grey))

#+END_SRC

Enable graphing with dot and ditaa

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ditaa . t)
     (dot . t)))

  (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")
  (setq org-ditaa-eps-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")

  (setq ditaa-cmd "java -jar <path-to-ditaa>ditaa0_6b.jar")
  (defun djcb-ditaa-generate ()
    (interactive)
    (shell-command
     (concat ditaa-cmd " " buffer-file-name)))
#+END_SRC

* Programming
*** Utilities

String manipulation routines for emacs lisp

#+BEGIN_SRC emacs-lisp
  (use-package s
    :ensure t)
#+END_SRC

Hydras are the most awesome thing in the world. Check out [[https://github.com/abo-abo/hydra][the project page]] for some great examples.

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC

*** Code Folding

#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :ensure t
    :bind (("C->" . my-toggle-hideshow-all)
           ("C-<" . hs-hide-level)
           ("C-;" . hs-toggle-hiding))
    :config
    ;; Hide the comments too when you do a 'hs-hide-all'
    (setq hs-hide-comments nil)
    ;; Set whether isearch opens folded comments, code, or both
    ;; where x is code, comments, t (both), or nil (neither)
    (setq hs-isearch-open 'x)
    ;; Add more here


    (setq hs-set-up-overlay
          (defun my-display-code-line-counts (ov)
            (when (eq 'code (overlay-get ov 'hs))
              (overlay-put ov 'display
                           (propertize
                            (format " ... <%d>"
                                    (count-lines (overlay-start ov)
                                                 (overlay-end ov)))
                            'face 'font-lock-type-face)))))

    (defvar my-hs-hide nil "Current state of hideshow for toggling all.")
         ;;;###autoload
    (defun my-toggle-hideshow-all () "Toggle hideshow all."
           (interactive)
           (setq my-hs-hide (not my-hs-hide))
           (if my-hs-hide
               (hs-hide-all)
             (hs-show-all)))

    (add-hook 'prog-mode-hook (lambda ()
                                (hs-minor-mode 1)
                                ))
    (add-hook 'clojure-mode-hook (lambda ()
                                (hs-minor-mode 1)
                                ))
    )
#+END_SRC

*** Look and feel

Enable the prettify symbols mode. It will translate (fn) to the lambda
sign.

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode 1)
#+END_SRC

*** Auto completion

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind (("C-c /". company-complete))
    :config
    (global-company-mode)
    )

;;  (use-package company-flx
;;    :ensure t
;;    :config
;;    (with-eval-after-load 'company
;;      (company-flx-mode +1)))
#+END_SRC
** All the icons

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+END_SRC

** Mode line

#+BEGIN_SRC emacs-lisp
(use-package mode-icons
  :ensure t
  :config
  (mode-icons-mode t))
  (setq mode-icons-desaturate-active t)
  (setq mode-icons-grayscale-transform nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;  (use-package spaceline
;;    :ensure t
;;    :init
;;    (setq powerline-default-separator 'utf-8)
;;
;;    :config
;;    (require 'spaceline-config)
;;    (spaceline-spacemacs-theme)
;;    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
    ;; Reference: https://github.com/hlissner/.emacs.d/blob/master/core/core-modeline.el

    (use-package f
      :ensure t)

    (use-package projectile
      :ensure t
      :config
      (add-hook 'prog-mode-hook 'projectile-mode))

    (use-package powerline
      :ensure t
      :config
      (defvar mode-line-height 30 "A little bit taller, a little bit baller.")

      (defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#909fab" nil)))
      (defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
      (defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#9091AB" nil)))

      ;; Custom faces
      (defface mode-line-is-modified nil
        "Face for mode-line modified symbol")

      (defface mode-line-2 nil
        "The alternate color for mode-line text.")

      (defface mode-line-highlight nil
        "Face for bright segments of the mode-line.")

      (defface mode-line-count-face nil
        "Face for anzu/evil-substitute/evil-search number-of-matches display.")

      ;; Git/VCS segment faces
      (defface mode-line-vcs-info '((t (:inherit warning)))
        "")
      (defface mode-line-vcs-warning '((t (:inherit warning)))
        "")

      ;; Flycheck segment faces
      (defface doom-flycheck-error '((t (:inherit error)))
        "Face for flycheck error feedback in the modeline.")
      (defface doom-flycheck-warning '((t (:inherit warning)))
        "Face for flycheck warning feedback in the modeline.")


      (defun doom-ml-flycheck-count (state)
        "Return flycheck information for the given error type STATE."
        (when (flycheck-has-current-errors-p state)
          (if (eq 'running flycheck-last-status-change)
              "?"
            (cdr-safe (assq state (flycheck-count-errors flycheck-current-errors))))))

      (defun doom-fix-unicode (font &rest chars)
        "Display certain unicode characters in a specific font.
    e.g. (doom-fix-unicode \"DejaVu Sans\" ?⚠ ?★ ?λ)"
        (declare (indent 1))
        (mapc (lambda (x) (set-fontset-font
                      t (cons x x)
                      (cond ((fontp font)
                             font)
                            ((listp font)
                             (font-spec :family (car font) :size (nth 1 font)))
                            ((stringp font)
                             (font-spec :family font))
                            (t (error "FONT is an invalid type: %s" font)))))
              chars))

      ;; Make certain unicode glyphs bigger for the mode-line.
      ;; FIXME Replace with all-the-icons?
      (doom-fix-unicode '("DejaVu Sans Mono" 15) ?✱) ;; modified symbol
      (let ((font "DejaVu Sans Mono for Powerline")) ;;
        (doom-fix-unicode (list font 12) ?)  ;; git symbol
        (doom-fix-unicode (list font 16) ?∄)  ;; non-existent-file symbol
        (doom-fix-unicode (list font 15) ?)) ;; read-only symbol

      ;; So the mode-line can keep track of "the current window"
      (defvar mode-line-selected-window nil)
      (defun doom|set-selected-window (&rest _)
        (let ((window (frame-selected-window)))
          (when (and (windowp window)
                     (not (minibuffer-window-active-p window)))
            (setq mode-line-selected-window window))))
      (add-hook 'window-configuration-change-hook #'doom|set-selected-window)
      (add-hook 'focus-in-hook #'doom|set-selected-window)
      (advice-add 'select-window :after 'doom|set-selected-window)
      (advice-add 'select-frame  :after 'doom|set-selected-window)

      (defun doom/project-root (&optional strict-p)
        "Get the path to the root of your project."
        (let (projectile-require-project-root strict-p)
          (projectile-project-root)))

      (defun *buffer-path ()
        "Displays the buffer's full path relative to the project root (includes the
    project root). Excludes the file basename. See `*buffer-name' for that."
        (when buffer-file-name
          (propertize
           (f-dirname
            (let ((buffer-path (file-relative-name buffer-file-name (doom/project-root)))
                  (max-length (truncate (/ (window-body-width) 1.75))))
              (concat (projectile-project-name) "/"
                      (if (> (length buffer-path) max-length)
                          (let ((path (reverse (split-string buffer-path "/" t)))
                                (output ""))
                            (when (and path (equal "" (car path)))
                              (setq path (cdr path)))
                            (while (and path (<= (length output) (- max-length 4)))
                              (setq output (concat (car path) "/" output))
                              (setq path (cdr path)))
                            (when path
                              (setq output (concat "../" output)))
                            (when (string-suffix-p "/" output)
                              (setq output (substring output 0 -1)))
                            output)
                        buffer-path))))
           'face (if active 'mode-line-2))))

      (defun *buffer-name ()
        "The buffer's base name or id."
        ;; FIXME Don't show uniquify tags
        (s-trim-left (format-mode-line "%b")))

      (defun *buffer-pwd ()
        "Displays `default-directory', for special buffers like the scratch buffer."
        (propertize
         (concat "[" (abbreviate-file-name default-directory) "]")
         'face 'mode-line-2))

      (defun *buffer-state ()
        "Displays symbols representing the buffer's state (non-existent/modified/read-only)"
        (when buffer-file-name
          (propertize
           (concat (if (not (file-exists-p buffer-file-name))
                       "∄"
                     (if (buffer-modified-p) "✱"))
                   (if buffer-read-only ""))
           'face 'mode-line-is-modified)))

      (defun *buffer-encoding-abbrev ()
        "The line ending convention used in the buffer."
        (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
            ""
          (symbol-name buffer-file-coding-system)))

      (defun *major-mode ()
        "The major mode, including process, environment and text-scale info."

;;(propertize 
  ;;          'face `(:family ,(all-the-icons-icon-family-for-buffer) :height 1.2)
    ;;        'display '(raise -0.1)))

      ;;  (format " %s"
      ;;    (propertize icon
      ;;                'help-echo (format "Major-mode: `%s`" major-mode)
      ;;                'face `(:height 1.2 :family ,(all-the-icons-icon-family-for-buffer)))))
      "The major mode, including process, environment and text-scale info."
      (concat (format-mode-line mode-name)
              (if (stringp mode-line-process) mode-line-process)
              (and (featurep 'face-remap)
                   (/= text-scale-mode-amount 0)
                   (format " (%+d)" text-scale-mode-amount))))

      (defun *vc ()
        "Displays the current branch, colored based on its state."
        (when vc-mode
          (let ((backend (concat " " (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))
                (face (let ((state (vc-state buffer-file-name)))
                        (cond ((memq state '(edited added))
                               'mode-line-vcs-info)
                              ((memq state '(removed needs-merge needs-update conflict removed unregistered))
                               'mode-line-vcs-warning)))))
            (if active
                (propertize backend 'face face)
              backend))))

      (defvar-local doom--flycheck-err-cache nil "")
      (defvar-local doom--flycheck-cache nil "")
      (defun *flycheck ()
        "Persistent and cached flycheck indicators in the mode-line."
        (when (and (featurep 'flycheck)
                   flycheck-mode
                   (or flycheck-current-errors
                       (eq 'running flycheck-last-status-change)))
          (or (and (or (eq doom--flycheck-err-cache doom--flycheck-cache)
                       (memq flycheck-last-status-change '(running not-checked)))
                   doom--flycheck-cache)
              (and (setq doom--flycheck-err-cache flycheck-current-errors)
                   (setq doom--flycheck-cache
                         (let ((fe (doom-ml-flycheck-count 'error))
                               (fw (doom-ml-flycheck-count 'warning)))
                           (concat
                            (if fe (propertize (format " •%d " fe)
                                               'face (if active
                                                         'doom-flycheck-error
                                                       'mode-line)))
                            (if fw (propertize (format " •%d " fw)
                                               'face (if active
                                                         'doom-flycheck-warning
                                                       'mode-line))))))))))

      (defun *buffer-position ()
        "A more vim-like buffer position."
        (let ((start (window-start))
              (end (window-end))
              (pend (point-max)))
          (if (and (= start 1)
                   (= end pend))
              ":All"
            (cond ((= start 1) ":Top")
                  ((= end pend) ":Bot")
                  (t (format ":%d%%%%" (/ end 0.01 pend)))))))

      (defun my-mode-line (&optional id)
        `(:eval
          (let* ((active (eq (selected-window) mode-line-selected-window))
                 (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
                            (*flycheck)
                            " "
                            (*buffer-path)
                            (*buffer-name)
                            " "
                            (*buffer-state)
                            ,(if (eq id 'scratch) '(*buffer-pwd))))
                 (rhs (list (*buffer-encoding-abbrev) "  "
                            (*vc)
  ;;                          " "
  ;;                          (when persp-curr persp-modestring)
                            " " (*major-mode) "  "
                            (propertize
                             (concat "(%l,%c) " (*buffer-position))
                             'face (if active 'mode-line-2))))
                 (middle (propertize
                          " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                                             ,(1+ (string-width (format-mode-line rhs)))))))))
            (list lhs middle rhs))))

      (setq-default mode-line-format (my-mode-line)))
#+END_SRC

